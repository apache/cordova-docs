<h1 id="android-plugins">Android Plugins</h1>

<p>This section provides details for how to implement native plugin code
on the Android platform. Before reading this, see Application Plugins
for an overview of the plugin’s structure and its common JavaScript
interface. This section continues to demonstrate the sample <em>echo</em>
plugin that communicates from the Cordova webview to the native
platform and back.  For another sample, see also the comments in
<a href="https://github.com/apache/cordova-android/blob/master/framework/src/org/apache/cordova/CordovaPlugin.java">CordovaPlugin.java</a>.</p>

<p>Android plugins are based on Cordova-Android, which consists of an
Android WebView with hooks attached to it.  Plugins are represented as
class mappings in the <code class="language-plaintext highlighter-rouge">config.xml</code> file.  A plugin consists of at
least one Java class that extends the <code class="language-plaintext highlighter-rouge">CordovaPlugin</code> class,
overriding one of its <code class="language-plaintext highlighter-rouge">execute</code> methods. As best practice, the plugin
should also handle <a href="../../../cordova/events/events.pause.html"><code class="language-plaintext highlighter-rouge">pause</code></a> and <a href="../../../cordova/events/events.resume.html"><code class="language-plaintext highlighter-rouge">resume</code></a> events, along with any message
passing between plugins.  Plugins with long-running requests,
background activity such as media playback, listeners, or internal
state should implement the <code class="language-plaintext highlighter-rouge">onReset()</code> method as well. It executes
when the <code class="language-plaintext highlighter-rouge">WebView</code> navigates to a new page or refreshes, which reloads
the JavaScript.</p>

<h2 id="plugin-class-mapping">Plugin Class Mapping</h2>

<p>The plugin’s JavaScript interface uses the <code class="language-plaintext highlighter-rouge">cordova.exec</code> method as
follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    exec(&lt;successFunction&gt;, &lt;failFunction&gt;, &lt;service&gt;, &lt;action&gt;, [&lt;args&gt;]);
</code></pre></div></div>

<p>This marshals a request from the WebView to the Android native side,
effectively calling the <code class="language-plaintext highlighter-rouge">action</code> method on the <code class="language-plaintext highlighter-rouge">service</code> class, with
additional arguments passed in the <code class="language-plaintext highlighter-rouge">args</code> array.</p>

<p>Whether you distribute a plugin as Java file or as a <em>jar</em> file of its
own, the plugin must be specified in your Cordova-Android
application’s <code class="language-plaintext highlighter-rouge">res/xml/config.xml</code> file. See Application Plugins for
more information on how to use the <code class="language-plaintext highlighter-rouge">plugin.xml</code> file to inject this
<code class="language-plaintext highlighter-rouge">feature</code> element:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;feature name="&lt;service_name&gt;"&gt;
        &lt;param name="android-package" value="&lt;full_name_including_namespace&gt;" /&gt;
    &lt;/feature&gt;
</code></pre></div></div>

<p>The service name matches the one used in the JavaScript <code class="language-plaintext highlighter-rouge">exec</code> call.
The value is the Java class’s fully qualified namespace identifier.
Otherwise, the plugin may compile but still be unavailable to Cordova.</p>

<h2 id="plugin-initialization-and-lifetime">Plugin Initialization and Lifetime</h2>

<p>One instance of a plugin object is created for the life of each
<code class="language-plaintext highlighter-rouge">WebView</code>. Plugins are not instantiated until they are first
referenced by a call from JavaScript, unless <code class="language-plaintext highlighter-rouge">&lt;param&gt;</code> with an <code class="language-plaintext highlighter-rouge">onload</code>
<code class="language-plaintext highlighter-rouge">name</code> attribute is set to <code class="language-plaintext highlighter-rouge">"true"</code> in <code class="language-plaintext highlighter-rouge">config.xml</code>. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;feature name="Echo"&gt;
    &lt;param name="android-package" value="&lt;full_name_including_namespace&gt;" /&gt;
    &lt;param name="onload" value="true" /&gt;
&lt;/feature&gt;
</code></pre></div></div>

<p>Plugins should use the <code class="language-plaintext highlighter-rouge">initialize</code> method for their start-up logic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override
public void initialize(CordovaInterface cordova, CordovaWebView webView) {
    super.initialize(cordova, webView);
    // your init code here
}
</code></pre></div></div>

<h2 id="writing-an-android-java-plugin">Writing an Android Java Plugin</h2>

<p>A JavaScript call fires off a plugin request to the native side, and
the corresponding Java plugin is mapped properly in the <code class="language-plaintext highlighter-rouge">config.xml</code>
file, but what does the final Android Java Plugin class look like?
Whatever is dispatched to the plugin with JavaScript’s <code class="language-plaintext highlighter-rouge">exec</code> function
is passed into the plugin class’s <code class="language-plaintext highlighter-rouge">execute</code> method. Most <code class="language-plaintext highlighter-rouge">execute</code>
implementations look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {
        if ("beep".equals(action)) {
            this.beep(args.getLong(0));
            callbackContext.success();
            return true;
        }
        return false;  // Returning false results in a "MethodNotFound" error.
    }
</code></pre></div></div>

<p>The JavaScript <code class="language-plaintext highlighter-rouge">exec</code> function’s <code class="language-plaintext highlighter-rouge">action</code> parameter corresponds to a
private class method to dispatch with optional parameters.</p>

<p>When catching exceptions and returning errors, it’s important for the
sake of clarity that errors returned to JavaScript match Java’s
exception names as much as possible.</p>

<h2 id="threading">Threading</h2>

<p>The plugin’s JavaScript does <em>not</em> run in the main thread of the
<code class="language-plaintext highlighter-rouge">WebView</code> interface; instead, it runs on the <code class="language-plaintext highlighter-rouge">WebCore</code> thread, as
does the <code class="language-plaintext highlighter-rouge">execute</code> method.  If you need to interact with the user
interface, you should use the following variation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
        if ("beep".equals(action)) {
            final long duration = args.getLong(0);
            cordova.getActivity().runOnUiThread(new Runnable() {
                public void run() {
                    ...
                    callbackContext.success(); // Thread-safe.
                }
            });
            return true;
        }
        return false;
    }
</code></pre></div></div>

<p>Use the following if you do not need to run on the main interface’s
thread, but do not want to block the <code class="language-plaintext highlighter-rouge">WebCore</code> thread either:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
        if ("beep".equals(action)) {
            final long duration = args.getLong(0);
            cordova.getThreadPool().execute(new Runnable() {
                public void run() {
                    ...
                    callbackContext.success(); // Thread-safe.
                }
            });
            return true;
        }
        return false;
    }
</code></pre></div></div>

<h2 id="adding-dependency-libraries">Adding Dependency Libraries</h2>

<p>If a plugin requires additional libraries to work, you can use
one of the following approaches to add them via <code class="language-plaintext highlighter-rouge">config.xml</code>.</p>

<p>Option A. Via <em>Gradle</em> reference, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;framework src="com.android.support:support-v4:+" /&gt;
</code></pre></div></div>

<p>This is a recommended approach as it allows multiple plugins
to refer to the same dependency library such as <em>gson</em>,
<em>android-support-v4</em>, <em>google-play-services</em>, etc and
<em>Gradle</em> will resolve duplicate dependencies using its
<a href="https://docs.gradle.org/current/userguide/dependency_management.html">Dependency Management logic</a>.</p>

<p>Option B. As <em>JAR</em> files placed to some plugin’s folder and
linked using <code class="language-plaintext highlighter-rouge">lib-file</code>, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;lib-file src="src/android/libs/gcm.jar"/&gt;
</code></pre></div></div>

<p>We recommend using this approach only if you are sure that
dependency jar is plugin specific and won’t be used by
other plugins. Otherwise, there will be platform build issue.</p>

<h2 id="echo-android-plugin-example">Echo Android Plugin Example</h2>

<p>To match the JavaScript interface’s <em>echo</em> feature described in
Application Plugins, use the <code class="language-plaintext highlighter-rouge">plugin.xml</code> to inject a <code class="language-plaintext highlighter-rouge">feature</code>
specification to the local platform’s <code class="language-plaintext highlighter-rouge">config.xml</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;platform name="android"&gt;
        &lt;config-file target="config.xml" parent="/*"&gt;
            &lt;feature name="Echo"&gt;
                &lt;param name="android-package" value="org.apache.cordova.plugin.Echo"/&gt;
            &lt;/feature&gt;
        &lt;/config-file&gt;
    &lt;/platform&gt;
</code></pre></div></div>

<p>Then add the following to the
<code class="language-plaintext highlighter-rouge">src/org/apache/cordova/plugin/Echo.java</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package org.apache.cordova.plugin;

    import org.apache.cordova.CordovaPlugin;
    import org.apache.cordova.CallbackContext;

    import org.json.JSONArray;
    import org.json.JSONException;
    import org.json.JSONObject;

    /**
     * This class echoes a string called from JavaScript.
     */
    public class Echo extends CordovaPlugin {

        @Override
        public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {
            if (action.equals("echo")) {
                String message = args.getString(0);
                this.echo(message, callbackContext);
                return true;
            }
            return false;
        }

        private void echo(String message, CallbackContext callbackContext) {
            if (message != null &amp;&amp; message.length() &gt; 0) {
                callbackContext.success(message);
            } else {
                callbackContext.error("Expected one non-empty string argument.");
            }
        }
    }
</code></pre></div></div>

<p>The necessary imports at the top of the file extends the class from
<code class="language-plaintext highlighter-rouge">CordovaPlugin</code>, whose <code class="language-plaintext highlighter-rouge">execute()</code> method it overrides to receive
messages from <code class="language-plaintext highlighter-rouge">exec()</code>.  The <code class="language-plaintext highlighter-rouge">execute()</code> method first tests the value
of <code class="language-plaintext highlighter-rouge">action</code>, for which in this case there is only one valid <code class="language-plaintext highlighter-rouge">echo</code>
value.  Any other action returns <code class="language-plaintext highlighter-rouge">false</code> and results in an
<code class="language-plaintext highlighter-rouge">INVALID_ACTION</code> error, which translates to an error callback invoked
on the JavaScript side.</p>

<p>Next, the method retrieves the echo string using the <code class="language-plaintext highlighter-rouge">args</code> object’s
<code class="language-plaintext highlighter-rouge">getString</code> method, specifying the first parameter passed to the
method.  After the value is passed to a private <code class="language-plaintext highlighter-rouge">echo</code> method, it is
parameter-checked to make sure it is not <code class="language-plaintext highlighter-rouge">null</code> or an empty string, in
which case <code class="language-plaintext highlighter-rouge">callbackContext.error()</code> invokes JavaScript’s error
callback.  If the various checks pass, the <code class="language-plaintext highlighter-rouge">callbackContext.success()</code>
passes the original <code class="language-plaintext highlighter-rouge">message</code> string back to JavaScript’s success
callback as a parameter.</p>

<h2 id="android-integration">Android Integration</h2>

<p>Android features an <code class="language-plaintext highlighter-rouge">Intent</code> system that allows processes to
communicate with each other.  Plugins have access to a
<code class="language-plaintext highlighter-rouge">CordovaInterface</code> object, which can access the Android <code class="language-plaintext highlighter-rouge">Activity</code>
that runs the application.  This is the <code class="language-plaintext highlighter-rouge">Context</code> required to launch a
new Android <code class="language-plaintext highlighter-rouge">Intent</code>.  The <code class="language-plaintext highlighter-rouge">CordovaInterface</code> allows plugins to start
an <code class="language-plaintext highlighter-rouge">Activity</code> for a result, and to set the callback plugin for when
the <code class="language-plaintext highlighter-rouge">Intent</code> returns to the application.</p>

<p>As of Cordova 2.0, Plugins can no longer directly access the
<code class="language-plaintext highlighter-rouge">Context</code>, and the legacy <code class="language-plaintext highlighter-rouge">ctx</code> member is deprecated. All <code class="language-plaintext highlighter-rouge">ctx</code>
methods exist on the <code class="language-plaintext highlighter-rouge">Context</code>, so both <code class="language-plaintext highlighter-rouge">getContext()</code> and
<code class="language-plaintext highlighter-rouge">getActivity()</code> can return the required object.</p>

<h2 id="android-permissions">Android Permissions</h2>

<p>Android permissions until recently have been handled at install-time instead
of runtime.  These permissions are required to be declared on an application that uses
the permissions, and these permissions need to be added to the Android Manifest.  This can be
accomplished by using the config.xml to inject these permissions in the AndroidManifest.xml file.
The example below uses the Contacts permission.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;config-file target="AndroidManifest.xml" parent="/*"&gt;
        &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;
    &lt;/config-file&gt;
</code></pre></div></div>

<h2 id="android-permissions-cordova-android-50x-and-greater">Android Permissions (Cordova-Android 5.0.x and greater)</h2>

<p>Android 6.0 “Marshmallow” introduced a new permissions model where
the user can turn on and off permissions as necessary.  This means that
applications must handle these permission changes to be future-proof, which
was the focus of the Cordova-Android 5.0 release.</p>

<p>The permissions that need to be handled at runtime can be found in the Android Developer
documentation <a href="http://developer.android.com/guide/topics/security/permissions.html#perm-groups">here</a>.</p>

<p>As far as a plugin is concerned, the permission can be requested by calling the permission method, which signature is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cordova.reqquestPermission(CordovaPlugin plugin, int requestCode, String permission);
</code></pre></div></div>

<p>To cut down on verbosity, it’s standard practice to assign this to a local static variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static final String READ = Manifest.permission.READ_CONTACTS;
</code></pre></div></div>

<p>It is also standard practice to define the requestCode as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static final int SEARCH_REQ_CODE = 0;
</code></pre></div></div>

<p>Then, in the exec method, the permission should be checked:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        if(cordova.hasPermission(READ)) {
            search(executeArgs);
        }
        else
        {
            getReadPermission(SEARCH_REQ_CODE);
        }
</code></pre></div></div>

<p>In this case, we just call requestPermission:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected void getReadPermission(int requestCode)
{
    cordova.requestPermission(this, requestCode, READ);
}
</code></pre></div></div>

<p>This will call the activity and cause a prompt to appear asking for the permission.  Once the user has the permission, the result must be handled with the onRequestPermissionResult method, which
every plugin should override.  An example of this can be found below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void onRequestPermissionResult(int requestCode, String[] permissions,
                                         int[] grantResults) throws JSONException
{
    for(int r:grantResults)
    {
        if(r == PackageManager.PERMISSION_DENIED)
        {
            this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, PERMISSION_DENIED_ERROR));
            return;
        }
    }
    switch(requestCode)
    {
        case SEARCH_REQ_CODE:
            search(executeArgs);
            break;
        case SAVE_REQ_CODE:
            save(executeArgs);
            break;
        case REMOVE_REQ_CODE:
            remove(executeArgs);
            break;
    }
}
</code></pre></div></div>

<p>The switch statement above would return from the prompt and depending on the requestCode that was passed in, it would call the method.  It should be noted that permission prompts may stack if the execution is not handled correctly, and that this should be avoided.</p>

<p>In addition to asking for permission for a single permission, it is also possible to request permissions for an entire group by defining the permissions array, as what is done with the Geolocation plugin:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String [] permissions = { Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION };
</code></pre></div></div>

<p>Then when requesting the permission, all that needs to be done is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cordova.requestPermissions(this, 0, permissions);
</code></pre></div></div>

<p>This requests the permissions specified in the array.  It’s a good idea to provide a publicly accessible permissions array since this can be used by plugins that use your plugin as a 
dependency, although this is not required.</p>

<h2 id="debugging-android-plugins">Debugging Android Plugins</h2>

<p>Android debugging can be done with either Eclipse or Android Studio, although Android
studio is recommended.  Since Cordova-Android is currently used as a library project,
and plugins are supported as source code, it is possible to debug the Java code inside 
a Cordova application just like a native Android application.</p>

