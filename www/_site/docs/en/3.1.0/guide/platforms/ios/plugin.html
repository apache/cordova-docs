<h1 id="ios-plugins">iOS Plugins</h1>

<p>A plugin is an Objective-C class that extends the <code class="language-plaintext highlighter-rouge">CDVPlugin</code> class.</p>

<p>Each plugin class must be registered as a <code class="language-plaintext highlighter-rouge">&lt;feature&gt;</code> tag in the
<code class="language-plaintext highlighter-rouge">config.xml</code> file. It is through this mechanism that JavaScript’s <code class="language-plaintext highlighter-rouge">exec</code>
method’s <code class="language-plaintext highlighter-rouge">service</code> parameter maps to an Objective-C class.</p>

<h2 id="plugin-class-mapping">Plugin Class Mapping</h2>

<p>The JavaScript portion of a plugin always uses the <code class="language-plaintext highlighter-rouge">cordova.exec</code> method as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exec(&lt;successFunction&gt;, &lt;failFunction&gt;, &lt;service&gt;, &lt;action&gt;, [&lt;args&gt;]);
</code></pre></div></div>

<p>This marshals a request from the <code class="language-plaintext highlighter-rouge">UIWebView</code> to the iOS native side,
more or less boiling down to calling the <code class="language-plaintext highlighter-rouge">action</code> method on the
<code class="language-plaintext highlighter-rouge">service</code> class, with the arguments passed in the <code class="language-plaintext highlighter-rouge">args</code> array.</p>

<p>Specifiy the plugin as a <code class="language-plaintext highlighter-rouge">&lt;feature&gt;</code> tag in your Cordova-iOS
application’s project’s <code class="language-plaintext highlighter-rouge">config.xml</code> file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;feature name="LocalStorage"&gt;
    &lt;param name="ios-package" value="CDVLocalStorage" /&gt;
&lt;/feature&gt;
</code></pre></div></div>

<p>The feature <code class="language-plaintext highlighter-rouge">name</code> attribute should match what you use in the JavaScript
<code class="language-plaintext highlighter-rouge">exec</code> call’s <code class="language-plaintext highlighter-rouge">service</code> parameter, and the <code class="language-plaintext highlighter-rouge">value</code> attribute should match the name of the plugin’s
Objective-C class. <code class="language-plaintext highlighter-rouge">&lt;param name&gt;</code> should always be <code class="language-plaintext highlighter-rouge">"ios-package"</code>.
If you do not follow this setup, the plugin may compile but will not be
reachable by Cordova.</p>

<h2 id="plugin-initialization-and-lifetime">Plugin Initialization and Lifetime</h2>

<p>One instance of a plugin object is created for the life of each
<code class="language-plaintext highlighter-rouge">UIWebView</code>. Plugins are not instantiated until they are first
referenced by a call from JavaScript, unless <code class="language-plaintext highlighter-rouge">&lt;param&gt;</code> with an <code class="language-plaintext highlighter-rouge">onload</code>
<code class="language-plaintext highlighter-rouge">name</code> attribute is set to <code class="language-plaintext highlighter-rouge">"true"</code> in <code class="language-plaintext highlighter-rouge">config.xml</code>. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;feature name="Echo"&gt;
    &lt;param name="ios-package" value="Echo" /&gt;
    &lt;param name="onload" value="true" /&gt;
&lt;/feature&gt;
</code></pre></div></div>

<p>There is <em>no</em> designated initializer for plugins. Instead, plugins
should use the <code class="language-plaintext highlighter-rouge">pluginInitialize</code> method for their start-up logic.</p>

<p>Plugins with long-running requests, background activity (e.g., playing
media), listeners or internal state should implement the <code class="language-plaintext highlighter-rouge">onReset</code>
method and stop or clean up those activities. This method is run when
the <code class="language-plaintext highlighter-rouge">UIWebView</code> navigates to a new page or refreshes, which reloads
the JavaScript.</p>

<h2 id="writing-an-ios-cordova-plugin">Writing an iOS Cordova Plugin</h2>

<p>We have JavaScript fire off a plugin request to the native side. We have the iOS Objective-C plugin mapped properly via the <code class="language-plaintext highlighter-rouge">config.xml</code> file. So what does the final iOS Objective-C Plugin class look like?</p>

<p>What gets dispatched to the plugin via JavaScript’s <code class="language-plaintext highlighter-rouge">exec</code> function gets passed into the corresponding Plugin class’s <code class="language-plaintext highlighter-rouge">action</code> method. A plugin method has this signature:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)myMethod:(CDVInvokedUrlCommand*)command
{
    CDVPluginResult* pluginResult = nil;
    NSString* myarg = [command.arguments objectAtIndex:0];

    if (myarg != nil) {
        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK];
    } else {
        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@"Arg was null"];
    }
    [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
}
</code></pre></div></div>

<ol>
  <li>
    <p><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVInvokedUrlCommand.h">CDVInvokedUrlCommand.h</a></p>
  </li>
  <li>
    <p><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVPluginResult.h">CDVPluginResult.h</a></p>
  </li>
  <li>
    <p><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVCommandDelegate.h">CDVCommandDelegate.h</a></p>
  </li>
</ol>

<h2 id="ios-cdvpluginresult-message-types">iOS CDVPluginResult message types</h2>

<p>Using CDVPluginResult you can return a variety of result types back to your JavaScript callbacks, using class methods that look like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (CDVPluginResult*)resultWithStatus:(CDVCommandStatus)statusOrdinal messageAs...
</code></pre></div></div>

<p>You can create <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">Array</code>,
<code class="language-plaintext highlighter-rouge">Dictionary</code>, <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, and <code class="language-plaintext highlighter-rouge">Multipart</code> types.  Or, don’t attach
any arguments (just send a status).  Or, return an Error.  You can
even choose to not send any plugin result at all, in which case the
callback does not fire.</p>

<h3 id="notes">Notes</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">messageAsArrayBuffer</code> expects <code class="language-plaintext highlighter-rouge">NSData*</code> and converts to an <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> for your JavaScript callback (and <code class="language-plaintext highlighter-rouge">ArrayBuffers</code> sent to a plugin from JavaScript are converted to <code class="language-plaintext highlighter-rouge">NSData*</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">messageAsMultipart</code> expects an <code class="language-plaintext highlighter-rouge">NSArray*</code> containing any of the other supported types, and sends the whole array as the <code class="language-plaintext highlighter-rouge">arguments</code> to your JavaScript callback.
    <ul>
      <li>Quirk: this is not just syntactic sugar (though it is sweet).  This way, all of the arguments are serialized or deserialized as necessary.  E.g., it is safe to return <code class="language-plaintext highlighter-rouge">NSData*</code> as multipart, but not as <code class="language-plaintext highlighter-rouge">Array</code>/<code class="language-plaintext highlighter-rouge">Dictionary</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="echo-plugin-ios-plugin">Echo Plugin iOS Plugin</h2>

<p>We would add the following to the project’s <code class="language-plaintext highlighter-rouge">config.xml</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;feature name="Echo"&gt;
    &lt;param name="ios-package" value="Echo" /&gt;
&lt;/feature&gt;
</code></pre></div></div>

<p>Then we would add the following files (<code class="language-plaintext highlighter-rouge">Echo.h</code> and <code class="language-plaintext highlighter-rouge">Echo.m</code>) to the Plugins directory inside our Cordova-iOS
application directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/********* Echo.h Cordova Plugin Header *******/

#import &lt;Cordova/CDV.h&gt;

@interface Echo : CDVPlugin

- (void)echo:(CDVInvokedUrlCommand*)command;

@end

/********* Echo.m Cordova Plugin Implementation *******/

#import "Echo.h"
#import &lt;Cordova/CDV.h&gt;

@implementation Echo

- (void)echo:(CDVInvokedUrlCommand*)command
{
    CDVPluginResult* pluginResult = nil;
    NSString* echo = [command.arguments objectAtIndex:0];

    if (echo != nil &amp;&amp; [echo length] &gt; 0) {
        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:echo];
    } else {
        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR];
    }

    [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
}

@end
</code></pre></div></div>

<p>Let’s take a look at the code. At the top we have all of the necessary
Cordova imports. Our class extends from <code class="language-plaintext highlighter-rouge">CDVPlugin</code> (very important).</p>

<p>This plugin only supports one action, the <code class="language-plaintext highlighter-rouge">echo</code> action. First, we
grab the echo string using the <code class="language-plaintext highlighter-rouge">objectAtIndex</code> method on our <code class="language-plaintext highlighter-rouge">args</code>,
telling it we want to get the 0th parameter in the arguments array. We
do a bit of parameter checking: make sure it is not <code class="language-plaintext highlighter-rouge">nil</code>, and make
sure it is not a zero-length string.</p>

<p>If it is, we return a <code class="language-plaintext highlighter-rouge">PluginResult</code> with an <code class="language-plaintext highlighter-rouge">ERROR</code> status. If all of
those checks pass, then we return a <code class="language-plaintext highlighter-rouge">PluginResult</code> with an <code class="language-plaintext highlighter-rouge">OK</code>
status, and pass in the <code class="language-plaintext highlighter-rouge">echo</code> string we received in the first place
as a parameter.</p>

<p>Finally, we send the result to <code class="language-plaintext highlighter-rouge">self.commandDelegate</code>, which executes
the <code class="language-plaintext highlighter-rouge">exec</code> method’s success or failure callbacks on the JavaScript
side. If the success callback is called, it passes in the <code class="language-plaintext highlighter-rouge">echo</code>
parameter.</p>

<h2 id="threading">Threading</h2>

<p>Plugin methods are executed in the same thread as the UI. If your
plugin requires a great deal of processing or requires a blocking
call, you should use a background thread. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)myPluginMethod:(CDVInvokedUrlCommand*)command
{
    // Check command.arguments here.
    [self.commandDelegate runInBackground:^{
        NSString* payload = nil;
        // Some blocking logic...
        CDVPluginResult* pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:payload];
        // The sendPluginResult method is thread-safe.
        [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
    }];
}
</code></pre></div></div>

<h2 id="advanced-plugin-functionality">Advanced Plugin Functionality</h2>

<p>See other methods that you can override in:</p>

<ul>
  <li>
    <p><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVPlugin.h">CDVPlugin.h</a></p>
  </li>
  <li>
    <p><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVPlugin.m">CDVPlugin.m</a></p>
  </li>
</ul>

<p>For example, you can hook into the <a href="../../../cordova/events/events.pause.html"><code class="language-plaintext highlighter-rouge">pause</code></a>, <a href="../../../cordova/events/events.resume.html"><code class="language-plaintext highlighter-rouge">resume</code></a>, app terminate and <code class="language-plaintext highlighter-rouge">handleOpenURL</code> events.</p>

<h2 id="debugging-plugins">Debugging Plugins</h2>

<p>To debug the Objective-C side, you would use Xcode’s built-in debugger.
For JavaScript, on iOS 5.0 you can use
<a href="https://github.com/apache/cordova-weinre">Weinre, an Apache Cordova Project</a> or
<a href="http://www.iwebinspector.com/">iWebInspector, a third-party utility</a></p>

<p>For iOS 6, you would use Safari 6.0 to simply attach to your app
running in the iOS 6 Simulator.</p>

<h2 id="common-pitfalls">Common Pitfalls</h2>

<ul>
  <li>
    <p>Don’t forget to add your plugin’s mapping to config.xml. If you forget, an error is logged in the Xcode console.</p>
  </li>
  <li>
    <p>Don’t forget to add any hosts you connect to in the whitelist, as described in Domain <a href="../../appdev/whitelist/index.html">Whitelist Guide</a>. If you forget, an error is logged in the Xcode console.</p>
  </li>
</ul>
