<h1 id="ios-plugin-development-guide">iOS Plugin Development Guide</h1>

<p>This section provides details for how to implement native plugin code
on the iOS platform.</p>

<p>Before reading this, see <a href="../../hybrid/plugins/index.html">Plugin Development Guide</a> for
an overview of the plugin’s structure and its common JavaScript
interface. This section continues to demonstrate the sample <em>echo</em>
plugin that communicates from the Cordova webview to the native
platform and back.</p>

<p>An iOS plugin is implemented as an Objective-C class that extends the
<code class="language-plaintext highlighter-rouge">CDVPlugin</code> class.  For JavaScript’s <code class="language-plaintext highlighter-rouge">exec</code> method’s <code class="language-plaintext highlighter-rouge">service</code>
parameter to map to an Objective-C class, each plugin class must be
registered as a <code class="language-plaintext highlighter-rouge">&lt;feature&gt;</code> tag in the named application directory’s
<code class="language-plaintext highlighter-rouge">config.xml</code> file.</p>

<h2 id="plugin-class-mapping">Plugin Class Mapping</h2>

<p>The JavaScript portion of a plugin uses the <code class="language-plaintext highlighter-rouge">cordova.exec</code> method as
follows:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exec</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">successFunction</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="nx">failFunction</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="nx">service</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="nx">action</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">[</span><span class="o">&lt;</span><span class="nx">args</span><span class="o">&gt;</span><span class="p">]);</span>
</code></pre></div></div>

<p>This marshals a request from the <code class="language-plaintext highlighter-rouge">UIWebView</code> to the iOS native side,
effectively calling the <code class="language-plaintext highlighter-rouge">action</code> method on the <code class="language-plaintext highlighter-rouge">service</code> class, with
the arguments passed in the <code class="language-plaintext highlighter-rouge">args</code> array.</p>

<p>Specify the plugin as a <code class="language-plaintext highlighter-rouge">&lt;feature&gt;</code> tag in your Cordova-iOS
application’s project’s <code class="language-plaintext highlighter-rouge">config.xml</code> file, using the <code class="language-plaintext highlighter-rouge">plugin.xml</code> file
to inject this markup automatically, as described in <a href="../../hybrid/plugins/index.html">Plugin Development Guide</a>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;feature</span> <span class="na">name=</span><span class="s">"LocalStorage"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"ios-package"</span> <span class="na">value=</span><span class="s">"CDVLocalStorage"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/feature&gt;</span>
</code></pre></div></div>

<p>The feature’s <code class="language-plaintext highlighter-rouge">name</code> attribute should match what you specify as the
JavaScript <code class="language-plaintext highlighter-rouge">exec</code> call’s <code class="language-plaintext highlighter-rouge">service</code> parameter. The <code class="language-plaintext highlighter-rouge">value</code> attribute
should match the name of the plugin’s Objective-C class. The <code class="language-plaintext highlighter-rouge">&lt;param&gt;</code>
element’s <code class="language-plaintext highlighter-rouge">name</code> should always be <code class="language-plaintext highlighter-rouge">ios-package</code>.  If you do not follow
these guidelines, the plugin may compile, but Cordova may still not be
able to access it.</p>

<h2 id="plugin-initialization-and-lifetime">Plugin Initialization and Lifetime</h2>

<p>One instance of a plugin object is created for the life of each
<code class="language-plaintext highlighter-rouge">UIWebView</code>. Plugins are not instantiated until they are first
referenced by a call from JavaScript, unless <code class="language-plaintext highlighter-rouge">&lt;param&gt;</code> with an <code class="language-plaintext highlighter-rouge">onload</code>
<code class="language-plaintext highlighter-rouge">name</code> attribute is set to <code class="language-plaintext highlighter-rouge">"true"</code> in <code class="language-plaintext highlighter-rouge">config.xml</code>. For example,</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;feature</span> <span class="na">name=</span><span class="s">"Echo"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"ios-package"</span> <span class="na">value=</span><span class="s">"Echo"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"onload"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/feature&gt;</span>
</code></pre></div></div>

<p>Plugins should use the <code class="language-plaintext highlighter-rouge">pluginInitialize</code> method for their startup logic.</p>

<p>Plugins with long-running requests or background activities such as media
playback, listeners, or that maintain internal state should implement
the <code class="language-plaintext highlighter-rouge">onReset</code> method to cancel those long-running requests or to clean up
after those activities.
The method runs when the <code class="language-plaintext highlighter-rouge">UIWebView</code> navigates to a new page or refreshes, which
reloads the JavaScript.</p>

<h2 id="writing-an-ios-cordova-plugin">Writing an iOS Cordova Plugin</h2>

<p>A JavaScript call fires off a plugin request to the native side, and
the corresponding iOS Objective-C plugin is mapped properly in the
<code class="language-plaintext highlighter-rouge">config.xml</code> file, but what does the final iOS Objective-C plugin
class look like?  Whatever is dispatched to the plugin with
JavaScript’s <code class="language-plaintext highlighter-rouge">exec</code> function is passed into the corresponding plugin
class’s <code class="language-plaintext highlighter-rouge">action</code> method. A plugin method has this signature:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myMethod</span><span class="p">:(</span><span class="n">CDVInvokedUrlCommand</span><span class="o">*</span><span class="p">)</span><span class="nv">command</span>
<span class="p">{</span>
    <span class="n">CDVPluginResult</span><span class="o">*</span> <span class="n">pluginResult</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">NSString</span><span class="o">*</span> <span class="n">myarg</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">.</span><span class="n">arguments</span> <span class="nf">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">myarg</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pluginResult</span> <span class="o">=</span> <span class="p">[</span><span class="n">CDVPluginResult</span> <span class="nf">resultWithStatus</span><span class="p">:</span><span class="n">CDVCommandStatus_OK</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">pluginResult</span> <span class="o">=</span> <span class="p">[</span><span class="n">CDVPluginResult</span> <span class="nf">resultWithStatus</span><span class="p">:</span><span class="n">CDVCommandStatus_ERROR</span> <span class="nf">messageAsString</span><span class="p">:</span><span class="s">@"Arg was null"</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">commandDelegate</span> <span class="nf">sendPluginResult</span><span class="p">:</span><span class="n">pluginResult</span> <span class="nf">callbackId</span><span class="p">:</span><span class="n">command</span><span class="p">.</span><span class="n">callbackId</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For more details, see
 <a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/Public/CDVInvokedUrlCommand.h">CDVInvokedUrlCommand.h</a>, <a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/Public/CDVPluginResult.h">CDVPluginResult.h</a>,
and <a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/Public/CDVCommandDelegate.h">CDVCommandDelegate.h</a>.</p>

<h2 id="ios-cdvpluginresult-message-types">iOS CDVPluginResult Message Types</h2>

<p>You can use <code class="language-plaintext highlighter-rouge">CDVPluginResult</code> to return a variety of result types back to
the JavaScript callbacks, using class methods that follow this pattern:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">+</span> <span class="p">(</span><span class="n">CDVPluginResult</span><span class="o">*</span><span class="p">)</span><span class="nf">resultWithStatus</span><span class="p">:(</span><span class="n">CDVCommandStatus</span><span class="p">)</span><span class="nv">statusOrdinal</span> <span class="n">messageAs</span><span class="p">...</span>
</code></pre></div></div>

<p>You can create <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">Bool</code>, <code class="language-plaintext highlighter-rouge">Array</code>,
<code class="language-plaintext highlighter-rouge">Dictionary</code>, <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, and <code class="language-plaintext highlighter-rouge">Multipart</code> types. You can also leave
out any arguments to send a status, or return an error, or even choose
not to send any plugin result, in which case neither callback fires.</p>

<p>Note the following for complex return values:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">messageAsArrayBuffer</code> expects <code class="language-plaintext highlighter-rouge">NSData*</code> and converts to an
<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> in the JavaScript callback. Likewise, any
<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> the JavaScript sends to a plugin are converted to
<code class="language-plaintext highlighter-rouge">NSData*</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">messageAsMultipart</code> expects an <code class="language-plaintext highlighter-rouge">NSArray*</code> containing any of the
other supported types, and sends the entire array as the <code class="language-plaintext highlighter-rouge">arguments</code>
to your JavaScript callback.  This way, all of the arguments are
serialized or deserialized as necessary, so it is safe to return
<code class="language-plaintext highlighter-rouge">NSData*</code> as multipart, but not as <code class="language-plaintext highlighter-rouge">Array</code>/<code class="language-plaintext highlighter-rouge">Dictionary</code>.</p>
  </li>
</ul>

<h2 id="echo-ios-plugin-example">Echo iOS Plugin Example</h2>

<p>To match the JavaScript interface’s <em>echo</em> feature described in
Application Plugins, use the <code class="language-plaintext highlighter-rouge">plugin.xml</code> to inject a <code class="language-plaintext highlighter-rouge">feature</code>
specification to the local platform’s <code class="language-plaintext highlighter-rouge">config.xml</code> file:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;platform</span> <span class="na">name=</span><span class="s">"ios"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config-file</span> <span class="na">target=</span><span class="s">"config.xml"</span> <span class="na">parent=</span><span class="s">"/*"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;feature</span> <span class="na">name=</span><span class="s">"Echo"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"ios-package"</span> <span class="na">value=</span><span class="s">"Echo"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/feature&gt;</span>
    <span class="nt">&lt;/config-file&gt;</span>
<span class="nt">&lt;/platform&gt;</span>
</code></pre></div></div>

<p>Then we would add the following <code class="language-plaintext highlighter-rouge">Echo.h</code> and <code class="language-plaintext highlighter-rouge">Echo.m</code> files to the
<code class="language-plaintext highlighter-rouge">Plugins</code> folder within the Cordova-iOS application directory:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/********* Echo.h Cordova Plugin Header *******/</span>

<span class="cp">#import &lt;Cordova/CDVPlugin.h&gt;
</span>
<span class="k">@interface</span> <span class="nc">Echo</span> <span class="p">:</span> <span class="nc">CDVPlugin</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">echo</span><span class="p">:(</span><span class="n">CDVInvokedUrlCommand</span><span class="o">*</span><span class="p">)</span><span class="nv">command</span><span class="p">;</span>

<span class="k">@end</span>

<span class="cm">/********* Echo.m Cordova Plugin Implementation *******/</span>

<span class="cp">#import "Echo.h"
#import &lt;Cordova/CDVPlugin.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">Echo</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">echo</span><span class="p">:(</span><span class="n">CDVInvokedUrlCommand</span><span class="o">*</span><span class="p">)</span><span class="nv">command</span>
<span class="p">{</span>
    <span class="n">CDVPluginResult</span><span class="o">*</span> <span class="n">pluginResult</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">NSString</span><span class="o">*</span> <span class="n">echo</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">.</span><span class="n">arguments</span> <span class="nf">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">echo</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">echo</span> <span class="nf">length</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pluginResult</span> <span class="o">=</span> <span class="p">[</span><span class="n">CDVPluginResult</span> <span class="nf">resultWithStatus</span><span class="p">:</span><span class="n">CDVCommandStatus_OK</span> <span class="nf">messageAsString</span><span class="p">:</span><span class="n">echo</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">pluginResult</span> <span class="o">=</span> <span class="p">[</span><span class="n">CDVPluginResult</span> <span class="nf">resultWithStatus</span><span class="p">:</span><span class="n">CDVCommandStatus_ERROR</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">commandDelegate</span> <span class="nf">sendPluginResult</span><span class="p">:</span><span class="n">pluginResult</span> <span class="nf">callbackId</span><span class="p">:</span><span class="n">command</span><span class="p">.</span><span class="n">callbackId</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>

<p>The necessary imports at the top of the file extends the class from
<code class="language-plaintext highlighter-rouge">CDVPlugin</code>.  In this case, the plugin only supports a single <code class="language-plaintext highlighter-rouge">echo</code>
action. It obtains the echo string by calling the <code class="language-plaintext highlighter-rouge">objectAtIndex</code>
method get the first parameter of the <code class="language-plaintext highlighter-rouge">arguments</code> array, which
corresponds to the arguments passed in by the JavaScript <code class="language-plaintext highlighter-rouge">exec()</code>
function.</p>

<p>It checks the parameter to make sure it is not <code class="language-plaintext highlighter-rouge">nil</code> or an empty
string, returning a <code class="language-plaintext highlighter-rouge">PluginResult</code> with an <code class="language-plaintext highlighter-rouge">ERROR</code> status if so.  If
the parameter passes the check, it returns a <code class="language-plaintext highlighter-rouge">PluginResult</code> with an
<code class="language-plaintext highlighter-rouge">OK</code> status, passing in the original <code class="language-plaintext highlighter-rouge">echo</code> string.  Finally, it sends
the result to <code class="language-plaintext highlighter-rouge">self.commandDelegate</code>, which executes the <code class="language-plaintext highlighter-rouge">exec</code>
method’s success or failure callbacks on the JavaScript side. If the
success callback is called, it passes in the <code class="language-plaintext highlighter-rouge">echo</code> parameter.</p>

<h2 id="ios-integration">iOS Integration</h2>

<p>The <code class="language-plaintext highlighter-rouge">CDVPlugin</code> class features other methods that your plugin can
override.  For example, you can capture the <a href="../../../cordova/events/events.html#pause">pause</a>, <a href="../../../cordova/events/events.html#resume">resume</a>, app
terminate and <code class="language-plaintext highlighter-rouge">handleOpenURL</code> events. See the
<a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/Public/CDVPlugin.h">CDVPlugin.h</a> and <a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/Public/CDVPlugin.m">CDVPlugin.m</a>
classes for guidance.</p>

<h2 id="threading">Threading</h2>

<p>Plugin methods ordinarily execute in the same thread as the main
interface. If your plugin requires a great deal of processing or
requires a blocking call, you should use a background thread. For
example:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myPluginMethod</span><span class="p">:(</span><span class="n">CDVInvokedUrlCommand</span><span class="o">*</span><span class="p">)</span><span class="nv">command</span>
<span class="p">{</span>
    <span class="c1">// Check command.arguments here.</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">commandDelegate</span> <span class="nf">runInBackground</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSString</span><span class="o">*</span> <span class="n">payload</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="c1">// Some blocking logic...</span>
        <span class="n">CDVPluginResult</span><span class="o">*</span> <span class="n">pluginResult</span> <span class="o">=</span> <span class="p">[</span><span class="n">CDVPluginResult</span> <span class="nf">resultWithStatus</span><span class="p">:</span><span class="n">CDVCommandStatus_OK</span> <span class="nf">messageAsString</span><span class="p">:</span><span class="n">payload</span><span class="p">];</span>
        <span class="c1">// The sendPluginResult method is thread-safe.</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">commandDelegate</span> <span class="nf">sendPluginResult</span><span class="p">:</span><span class="n">pluginResult</span> <span class="nf">callbackId</span><span class="p">:</span><span class="n">command</span><span class="p">.</span><span class="n">callbackId</span><span class="p">];</span>
    <span class="p">}];</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="debugging-ios-plugins">Debugging iOS Plugins</h2>

<p>To debug on the Objective-C side, you need Xcode’s built-in debugger.
For JavaScript, you can attach Safari to the app running within the iOS Simulator/Device.</p>

<h2 id="common-pitfalls">Common Pitfalls</h2>

<ul>
  <li>
    <p>Don’t forget to add your plugin’s mapping to <code class="language-plaintext highlighter-rouge">config.xml</code>. If you
forget, an error is logged in the Xcode console.</p>
  </li>
  <li>
    <p>Don’t forget to add any hosts you connect to in the whitelist, as
described in Domain <a href="../../appdev/whitelist/index.html">Whitelist Guide</a>. If you forget, an error is
logged in the Xcode console.</p>
  </li>
</ul>

