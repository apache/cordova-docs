<h1 id="developing-a-plugin-on-windows-phone">Developing a Plugin on Windows Phone</h1>

<p>Writing a plugin for Cordova on Windows Phone requires a basic understanding of
the architecture of Cordova. Cordova-WP7 consists of a WebBrowser which hosts the
application javascript code and manages native API calls. There is a BaseCommand
(<code class="language-plaintext highlighter-rouge">WP7CordovaClassLib.Cordova.Commands.BaseCommand</code>) class in C# which you can extend,
and it comes with the majority of the ‘plumbing’ built for you already.</p>

<ol>
  <li>Select your project, and right click choose ‘Add -&gt; New Item …’
    <ul>
      <li>Preferably add it to the ‘Plugins’ folder, but it is up to you</li>
    </ul>
  </li>
  <li>Select ‘Class’ and name it <code class="language-plaintext highlighter-rouge">Echo.cs</code>
    <ul>
      <li>The name of this class must EXACTLY match what you call into <code class="language-plaintext highlighter-rouge">cordova.exec(win, fail, "Echo", ...)</code></li>
    </ul>
  </li>
  <li>
    <p>Include the base classes implementation</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> using WP7CordovaClassLib.Cordova;
 using WP7CordovaClassLib.Cordova.Commands;
 using WP7CordovaClassLib.Cordova.JSON;
</code></pre></div>    </div>
  </li>
  <li>
    <p>Extend your class from BaseCommand</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public class Echo : BaseCommand
 {
     // ...
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>Add a method that is callable from JS</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public class Echo : BaseCommand
 {
     public void echo(string options)
     {
         // all JS callable plugin methods MUST have this signature!
         // public, returning void, 1 argument that is a string
     }
 }
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="namespaces">Namespaces</h2>

<p>The default namespace for unqualified commands is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace Cordova.Extension.Commands
{
    // ...
}
</code></pre></div></div>

<p>If you would like to use your own namespace, you will need to make a fully qualified
call to <code class="language-plaintext highlighter-rouge">cordova.exec</code>. For example, if you wanted to define your C# class like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace com.mydomain.cordovaExtensions
{
    public class Echo : BaseCommand
    {
        // ...
    }
}
</code></pre></div></div>

<p>Then, in JS you would need to call exec like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>codova.exec(win, fail, "com.mydomain.cordovaExtensions.Echo", ...);
</code></pre></div></div>

<h2 id="interpretting-your-arguments-in-c">Interpretting your arguments in C#</h2>

<p>The data received by your plugin method is a string value, but in actuallality
looking at our JavaScript code, we see our intention was to pass an array of strings.
Looking back at our JS call to <code class="language-plaintext highlighter-rouge">cordova.exec</code>, we see we passed <code class="language-plaintext highlighter-rouge">[str]</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cordova.exec(win, fail, "Echo", "echo", ["input string"]);
</code></pre></div></div>

<p>If we inspect the options string passed in to our <code class="language-plaintext highlighter-rouge">Echo.echo</code> method, we will
see that the value is actually:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"[\"input string\"]"
</code></pre></div></div>

<p>All javascript exec arguments are JSON encoded before being passed into C#.</p>

<p>If we want to treat this as the string we were expecting, we need to decode it.
We can use simple JSON deserialization.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string optVal = JsonHelper.Deserialize&lt;string[]&gt;(options)[0];
// optVal now has the value of "input string"
</code></pre></div></div>

<h2 id="passing-results-from-c-to-js">Passing results from C# to JS</h2>

<p>The base class BaseCommand provides methods for passing data to your JS callback handlers.
To simply signal that the command has succeeded, when no additional result info is needed,
you can can simply call:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DispatchCommandResult(); // calls back with an empty plugin result, considered a success callback
</code></pre></div></div>

<p>To pass data back, you will need to call a different version of <code class="language-plaintext highlighter-rouge">DispatchCommandResult</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DispatchCommandResult(new PluginResult(PluginResult.Status.OK, "Everything went as planned, this is a result that is passed to the success handler."));
</code></pre></div></div>

<p>To pass structured object data back to JS, it should be encoded as a JSON string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DispatchCommandResult(new PluginResult(PluginResult.Status.OK, "{result:\"super awesome!\"}"));
</code></pre></div></div>

<p>If you need to signal that an error has occured, you can call <code class="language-plaintext highlighter-rouge">DispatchCommandResult</code> with a <code class="language-plaintext highlighter-rouge">PluginResult</code> object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DispatchCommandResult(new PluginResult(PluginResult.Status.ERROR, "Echo signalled an error"));
</code></pre></div></div>

<h2 id="handling-serialization-errors-in-your-plugins-c-method">Handling serialization errors in your plugin’s C# method</h2>

<p>When interpretting your arguments, it is a good idea to use a try/catch block
in case we have bad input. This is a pattern used throughout the Cordova C# code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string optVal = null;

try 
{
    optVal = JsonHelper.Deserialize&lt;string[]&gt;(options)[0];
}
catch(Exception)
{
    // simply catch the exception, we will handle null values and exceptions together
}

if (optVal == null)
{
    DispatchCommandResult(new PluginResult(PluginResult.Status.JSON_EXCEPTION));
}
else
{
    // ... continue on to do our work
}
</code></pre></div></div>

<h2 id="advanced-plugin-functionality">Advanced Plugin Functionality</h2>

<p>See other methods that you can override in:</p>

<ol>
  <li><a href="https://github.com/apache/cordova-wp7/blob/master/templates/standalone/cordovalib/Commands/BaseCommand.cs">BaseCommand.cs</a></li>
</ol>

<p>For example, you can hook into the ‘<a href="../../../cordova/events/events.pause.html">pause</a>’ and ‘<a href="../../../cordova/events/events.resume.html">resume</a>’ application events.</p>

<h3 id="debugging-plugins">Debugging Plugins</h3>

<p>To debug the C# side, you can use Visual Studio’s debugger, just set a break point
at any of the methods exposed by your class.</p>

<p>Javascript is a little more difficult to debug on Windows Phone, you will need to
use <code class="language-plaintext highlighter-rouge">console.log</code> to output the state of your plugin, or inform yourself of errors.</p>

<h2 id="common-pitfalls">Common Pitfalls</h2>

<ul>
  <li>
    <p>Be careful when deciding on the arguments you pass to native in your JavaScript
implementation. Most device platforms expect the args passed to cordova.exec
to be an array, but if you have different types of objects in this array, it
becomes difficult or impossible to deserialize.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  cordova.exec(win, fail, "ServiceName", "MethodName", ["this is a string", 54, {literal:'trouble'}]);
</code></pre></div>    </div>

    <ul>
      <li>
        <p>This will mean that your C# code will receive a difficult to decode string value, such as:</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "[\"this is a string\", 54, { literal:'trouble' }]"
</code></pre></div>        </div>
      </li>
      <li>
        <p>Consider converting ALL parameters to strings before calling exec:</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  cordova.exec(win, fail, "ServiceName", "MethodName", ["this is a string", "54", "{literal:'trouble'}"])	;

  string[] optValues = JsonHelper.Deserialize&lt;string[]&gt;(options);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>It is usually a good idea to do parameter checking in your JavaScript code,
before you call exec.  This will let you re-use more JS code between different
native implementations of your plugin.</p>
  </li>
</ul>

